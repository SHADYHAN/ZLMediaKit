<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZLMediaKit TURN ä¸­ç»§æµ‹è¯•å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 14px;
            opacity: 0.9;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        .panel {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .config-section {
            margin-bottom: 15px;
        }
        
        .config-section label {
            display: block;
            color: #555;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        .config-section input,
        .config-section select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        .config-section input:focus,
        .config-section select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        #video {
            width: 100%;
            height: auto;
            max-height: 400px;
            background: #000;
            border-radius: 8px;
            display: block;
        }
        
        #log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        #log::-webkit-scrollbar {
            width: 10px;
        }
        
        #log::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 5px;
        }
        
        #log::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 5px;
        }
        
        #log::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        
        .log-line {
            margin-bottom: 3px;
        }
        
        .log-info { color: #00ff00; }
        .log-warn { color: #ffa500; }
        .log-error { color: #ff4444; }
        .log-success { color: #00ff88; }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        
        .stat-label {
            color: #777;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #333;
            font-size: 20px;
            font-weight: bold;
        }
        
        .status-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 10px;
        }
        
        .status-disconnected {
            background: #dc3545;
            color: white;
        }
        
        .status-connecting {
            background: #ffc107;
            color: #333;
        }
        
        .status-connected {
            background: #28a745;
            color: white;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        @media (max-width: 1024px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .info-box h3 {
            color: #1976d2;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .info-box ul {
            margin-left: 20px;
            color: #555;
        }
        
        .info-box li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ ZLMediaKit TURN ä¸­ç»§æµ‹è¯•å·¥å…·</h1>
            <p>éªŒè¯ TURN æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸å·¥ä½œ | å¼ºåˆ¶ä½¿ç”¨ä¸­ç»§æ¨¡å¼</p>
        </div>
        
        <div class="content">
            <!-- å·¦ä¾§ï¼šé…ç½®å’Œæ§åˆ¶é¢æ¿ -->
            <div class="panel">
                <h2>âš™ï¸ é…ç½®å‚æ•°</h2>
                
                <div class="config-section">
                    <label>ZLM æœåŠ¡å™¨å®Œæ•´åœ°å€</label>
                    <input type="text" id="serverUrl" value="http://streams-12.vhalo.net:8888/index/api/webrtc" placeholder="http://streams-12.vhalo.net:8888/index/api/webrtc">
                    <small style="color: #777; font-size: 12px;">åŒ…å«åè®®ã€åŸŸåã€ç«¯å£å’Œè·¯å¾„</small>
                </div>
                
                <div class="config-section">
                    <label>åº”ç”¨å (app)</label>
                    <input type="text" id="app" value="264720" placeholder="ä¾‹å¦‚: live">
                </div>
                
                <div class="config-section">
                    <label>æµ ID (stream)</label>
                    <input type="text" id="stream" value="dg-111" placeholder="ä¾‹å¦‚: test">
                </div>
                
                <div class="config-section">
                    <label>TURN æœåŠ¡å™¨åœ°å€</label>
                    <input type="text" id="turnServer" value="turn:streams-cm-2.vhalo.net:3478?transport=udp" placeholder="turn:streams-cm-2.vhalo.net:3478?transport=udp">
                    <small style="color: #777; font-size: 12px;">é€šå¸¸å’Œ ZLM æœåŠ¡å™¨åŸŸåç›¸åŒ</small>
                </div>
                
                <div class="config-section">
                    <label>å¤–éƒ¨ IP/åŸŸåï¼ˆç”¨äº SDPï¼‰</label>
                    <input type="text" id="externIP" value="" placeholder="ä¾‹å¦‚: your-domain.com æˆ–å…¬ç½‘IP">
                    <small style="color: #777; font-size: 12px;">æ›¿æ¢ SDP ä¸­çš„å†…ç½‘ IPï¼Œç•™ç©ºåˆ™è‡ªåŠ¨ä» TURN åœ°å€æå–</small>
                </div>
                
                <div class="config-section">
                    <label>TURN ç”¨æˆ·å</label>
                    <input type="text" id="turnUsername" value="wawa" placeholder="ICE ç”¨æˆ·å">
                </div>
                
                <div class="config-section">
                    <label>TURN å¯†ç </label>
                    <input type="text" id="turnPassword" value="NAwR6DMuD7UNuTMh" placeholder="ICE å¯†ç ">
                </div>
                
                <div class="config-section">
                    <label>ICE ä¼ è¾“ç­–ç•¥ï¼ˆå®¢æˆ·ç«¯ï¼‰</label>
                    <select id="icePolicy">
                        <option value="all" selected>all - ä¼˜å…ˆ P2Pï¼Œå¤±è´¥åˆ™ TURN â­</option>
                        <option value="relay">relay - å¼ºåˆ¶å®¢æˆ·ç«¯ç”¨ TURNï¼ˆæµ‹è¯• TURNï¼‰</option>
                    </select>
                    <small style="color: #777; font-size: 12px;">âš ï¸ æœåŠ¡å™¨é…ç½®ä¿æŒ iceTransportPolicy=0</small>
                </div>
                
                <div class="info-box">
                    <h3>ğŸ’¡ ä½¿ç”¨è¯´æ˜</h3>
                    <ul>
                        <li><strong>ä¼˜å…ˆ P2P æ¨¡å¼ï¼ˆæ¨èï¼‰ï¼š</strong>é€‰æ‹© "all" ç­–ç•¥ï¼Œèƒ½ç›´è¿å°±ç›´è¿ï¼Œä¸è¡Œæ‰ç”¨ TURN</li>
                        <li><strong>å¼ºåˆ¶ä¸­ç»§æ¨¡å¼ï¼ˆæµ‹è¯•ï¼‰ï¼š</strong>é€‰æ‹© "relay" ç­–ç•¥ï¼ŒéªŒè¯ TURN æœåŠ¡å™¨æ˜¯å¦å·¥ä½œ</li>
                        <li>å¡«å†™å®Œæ•´çš„æœåŠ¡å™¨åœ°å€ï¼ˆåŒ…å« http:// æˆ– https://ï¼‰</li>
                        <li>é…ç½® TURN æœåŠ¡å™¨åœ°å€å’Œè®¤è¯ä¿¡æ¯</li>
                        <li>ç‚¹å‡»"å¼€å§‹æµ‹è¯•"æˆ–"ä»…æµ‹è¯• TURN è¿æ¥"</li>
                    </ul>
                </div>
                
                <div class="button-group">
                    <button class="btn-primary" onclick="startTest()">ğŸš€ å¼€å§‹å®Œæ•´æµ‹è¯•</button>
                    <button class="btn-success" onclick="testTurnOnly()">ğŸ”§ ä»…æµ‹è¯• TURN è¿æ¥</button>
                    <button class="btn-success" onclick="checkConnectionType()">ğŸ” æ£€æŸ¥è¿æ¥ç±»å‹</button>
                    <button class="btn-warning" onclick="getDetailedStats()">ğŸ“Š è¯¦ç»†ç»Ÿè®¡</button>
                    <button class="btn-danger" onclick="stopTest()">â¹ï¸ åœæ­¢</button>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">è¿æ¥çŠ¶æ€</div>
                        <div class="stat-value" id="connectionState">æœªè¿æ¥</div>
                        <div class="status-badge status-disconnected" id="statusBadge">ç¦»çº¿</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ICE çŠ¶æ€</div>
                        <div class="stat-value" id="iceState">new</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å€™é€‰ç±»å‹</div>
                        <div class="stat-value" id="candidateType">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">å¾€è¿”å»¶è¿Ÿ (RTT)</div>
                        <div class="stat-value" id="rtt">- ms</div>
                    </div>
                </div>
            </div>
            
            <!-- å³ä¾§ï¼šè§†é¢‘å’Œæ—¥å¿— -->
            <div class="panel">
                <h2>ğŸ“º è§†é¢‘æ’­æ”¾</h2>
                <video id="video" autoplay playsinline controls muted></video>
            </div>
            
            <div class="panel full-width">
                <h2>ğŸ“ å®æ—¶æ—¥å¿—</h2>
                <div id="log"></div>
            </div>
        </div>
    </div>
    
    <script>
        let pc = null;
        let startTime = null;
        
        // æ—¥å¿—å‡½æ•°
        function log(msg, type = 'info') {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            const className = `log-${type}`;
            logDiv.innerHTML += `<div class="log-line ${className}">[${time}] ${msg}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type}] ${msg}`);
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(connectionState, iceState) {
            document.getElementById('connectionState').textContent = connectionState;
            document.getElementById('iceState').textContent = iceState;
            
            const badge = document.getElementById('statusBadge');
            badge.className = 'status-badge';
            
            if (connectionState === 'connected') {
                badge.textContent = 'å·²è¿æ¥';
                badge.classList.add('status-connected');
            } else if (connectionState === 'connecting') {
                badge.textContent = 'è¿æ¥ä¸­';
                badge.classList.add('status-connecting');
            } else {
                badge.textContent = 'ç¦»çº¿';
                badge.classList.add('status-disconnected');
            }
        }
        
        // ä»…æµ‹è¯• TURN è¿æ¥ï¼ˆä¸è¿æ¥ ZLMï¼‰
        async function testTurnOnly() {
            clearLog();
            log('========================================', 'info');
            log('ğŸ”§ TURN æœåŠ¡å™¨è¿æ¥æµ‹è¯•', 'success');
            log('========================================', 'info');
            log('', 'info');
            log('ğŸ¯ æ­¤æµ‹è¯•ä»…éªŒè¯æµè§ˆå™¨èƒ½å¦ä» TURN æœåŠ¡å™¨è·å– relay å€™é€‰', 'info');
            log('   ä¸ä¼šè¿æ¥åˆ° ZLM æœåŠ¡å™¨ï¼Œä¸ä¼šæ’­æ”¾åª’ä½“æµ', 'info');
            log('', 'info');
            
            try {
                // è·å–é…ç½®
                const config = {
                    turnServer: document.getElementById('turnServer').value,
                    turnUsername: document.getElementById('turnUsername').value,
                    turnPassword: document.getElementById('turnPassword').value,
                    icePolicy: document.getElementById('icePolicy').value
                };
                
                log('ğŸ“‹ é…ç½®å‚æ•°:', 'info');
                log(`   TURN æœåŠ¡å™¨: ${config.turnServer}`, 'info');
                log(`   è®¤è¯ç”¨æˆ·å: ${config.turnUsername}`, 'info');
                log(`   ICE ç­–ç•¥: ${config.icePolicy}`, 'info');
                log('', 'info');
                
                // åˆ›å»ºä¸´æ—¶çš„ PeerConnection ä»…ç”¨äºæµ‹è¯• TURN
                const pcConfig = {
                    iceServers: [
                        {
                            urls: config.turnServer,
                            username: config.turnUsername,
                            credential: config.turnPassword
                        }
                    ],
                    iceTransportPolicy: config.icePolicy
                };
                
                const testPc = new RTCPeerConnection(pcConfig);
                log('âœ… PeerConnection å·²åˆ›å»º', 'success');
                log('', 'info');
                
                // å€™é€‰ç»Ÿè®¡
                let candidateStats = {
                    host: 0,
                    srflx: 0,
                    relay: 0,
                    total: 0
                };
                
                // ç›‘å¬ ICE å€™é€‰
                testPc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const c = event.candidate;
                        candidateStats.total++;
                        candidateStats[c.type] = (candidateStats[c.type] || 0) + 1;
                        
                        log(`ğŸ¯ ICE å€™é€‰ #${candidateStats.total}: ${c.type} | ${c.protocol} | ${c.address}:${c.port}`, 
                            c.type === 'relay' ? 'success' : 'warn');
                        log(`   ${c.candidate}`, 'info');
                    } else {
                        log('', 'info');
                        log('âœ… ICE å€™é€‰æ”¶é›†å®Œæˆ', 'success');
                        log(`ğŸ“Š ç»Ÿè®¡ç»“æœ: host=${candidateStats.host}, srflx=${candidateStats.srflx}, relay=${candidateStats.relay}`, 'info');
                        log('', 'info');
                        
                        // è¯Šæ–­ç»“æœ
                        if (candidateStats.relay > 0) {
                            log('========================================', 'success');
                            log('âœ…âœ…âœ… TURN æœåŠ¡å™¨è¿æ¥æˆåŠŸï¼', 'success');
                            log('========================================', 'success');
                            log(`   æˆåŠŸè·å– ${candidateStats.relay} ä¸ª relay å€™é€‰`, 'success');
                            log('   TURN æœåŠ¡å™¨å·¥ä½œæ­£å¸¸', 'success');
                            log('', 'success');
                            log('ğŸ’¡ ä¸‹ä¸€æ­¥ï¼šç‚¹å‡»"å¼€å§‹å®Œæ•´æµ‹è¯•"éªŒè¯åª’ä½“æµæ’­æ”¾', 'info');
                        } else {
                            log('========================================', 'error');
                            log('âŒâŒâŒ TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼', 'error');
                            log('========================================', 'error');
                            log('', 'error');
                            log('ğŸ” æœªè·å–åˆ°ä»»ä½• relay å€™é€‰ï¼Œå¯èƒ½åŸå› ï¼š', 'error');
                            log('', 'error');
                            log('1ï¸âƒ£  TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥', 'error');
                            log(`   â€¢ åŸŸåæ— æ³•è§£æ: ${config.turnServer.split(':')[1].replace('//', '')}`, 'error');
                            log('   â€¢ ç«¯å£ä¸é€š: 3478/udp', 'error');
                            log('   â€¢ é˜²ç«å¢™é˜»æ­¢', 'error');
                            log('', 'error');
                            log('2ï¸âƒ£  TURN è®¤è¯å¤±è´¥', 'error');
                            log(`   â€¢ å½“å‰ç”¨æˆ·å: ${config.turnUsername}`, 'error');
                            log('   â€¢ æ£€æŸ¥ ZLM config.ini ä¸­çš„ iceUfrag/icePwd', 'error');
                            log('', 'error');
                            log('3ï¸âƒ£  ZLM é…ç½®é—®é¢˜', 'error');
                            log('   â€¢ config.ini ä¸­ externIP æœªé…ç½®', 'error');
                            log('   â€¢ config.ini ä¸­ enableTurn=0', 'error');
                            log('', 'error');
                            log('ğŸ’¡ å»ºè®®æ“ä½œï¼š', 'warn');
                            log('   1. æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°ï¼ˆF12ï¼‰æŸ¥çœ‹é”™è¯¯ä¿¡æ¯', 'warn');
                            log('   2. è®¿é—® chrome://webrtc-internals æŸ¥çœ‹è¯¦ç»†æ—¥å¿—', 'warn');
                            log('   3. å‚è€ƒ "è¯Šæ–­è„šæœ¬-ZLMé…ç½®æ£€æŸ¥.md" æ–‡ä»¶', 'warn');
                            log('   4. æ£€æŸ¥ ZLM æœåŠ¡å™¨æ—¥å¿—: tail -f /opt/ZLMediaKit/log/*.log', 'warn');
                        }
                        
                        // æ¸…ç†
                        setTimeout(() => {
                            testPc.close();
                            log('', 'info');
                            log('ğŸ§¹ æµ‹è¯•è¿æ¥å·²å…³é—­', 'info');
                        }, 2000);
                    }
                };
                
                // ç›‘å¬ ICE çŠ¶æ€
                testPc.onicegatheringstatechange = () => {
                    log(`ğŸ“Š ICE æ”¶é›†çŠ¶æ€: ${testPc.iceGatheringState}`, 'info');
                };
                
                // æ·»åŠ è™šæ‹Ÿæ¥æ”¶å™¨ä»¥è§¦å‘ ICE æ”¶é›†
                testPc.addTransceiver('audio', { direction: 'recvonly' });
                
                // åˆ›å»º Offer è§¦å‘ ICE æ”¶é›†
                log('ğŸ” å¼€å§‹æ”¶é›† ICE å€™é€‰...', 'info');
                log('', 'info');
                const offer = await testPc.createOffer();
                await testPc.setLocalDescription(offer);
                
            } catch (error) {
                log('', 'error');
                log('âŒ æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                console.error('TURN test error:', error);
            }
        }
        
        // å¼€å§‹æµ‹è¯•
        async function startTest() {
            clearLog();
            log('========================================', 'info');
            log('ğŸš€ å¼€å§‹ TURN ä¸­ç»§æµ‹è¯•', 'success');
            log('========================================', 'info');
            
            startTime = Date.now();
            
            // è·å–é…ç½®
            const config = {
                serverUrl: document.getElementById('serverUrl').value,
                app: document.getElementById('app').value,
                stream: document.getElementById('stream').value,
                turnServer: document.getElementById('turnServer').value,
                turnUsername: document.getElementById('turnUsername').value,
                turnPassword: document.getElementById('turnPassword').value,
                icePolicy: document.getElementById('icePolicy').value,
                externIP: document.getElementById('externIP').value.trim()
            };
            
            log('ğŸ“‹ é…ç½®å‚æ•°:', 'info');
            log(`   æœåŠ¡å™¨: ${config.serverUrl}`, 'info');
            log(`   åº”ç”¨: ${config.app}`, 'info');
            log(`   æµID: ${config.stream}`, 'info');
            log(`   TURN: ${config.turnServer}`, 'info');
            log(`   ç­–ç•¥: ${config.icePolicy}`, 'warn');
            
            // åœæ­¢æ—§è¿æ¥
            if (pc) {
                pc.close();
                pc = null;
            }
            
            try {
                // åˆ›å»º RTCPeerConnection
                log('', 'info');
                log('ğŸ“¡ åˆ›å»º RTCPeerConnection...', 'info');
                
                // é…ç½® TURN æœåŠ¡å™¨
                const pcConfig = {
                    iceServers: [
                        {
                            urls: config.turnServer,
                            username: config.turnUsername,
                            credential: config.turnPassword
                        }
                    ],
                    iceTransportPolicy: config.icePolicy
                };
                
                pc = new RTCPeerConnection(pcConfig);
                log('âœ… PeerConnection å·²åˆ›å»º', 'success');
                
                if (config.icePolicy === 'relay') {
                    log('ğŸ”’ å·²å¯ç”¨å¼ºåˆ¶ TURN ä¸­ç»§æ¨¡å¼', 'warn');
                    log('   åªä¼šä½¿ç”¨ relay ç±»å‹çš„å€™é€‰', 'warn');
                }
                
                // æ·»åŠ æ¥æ”¶å™¨ï¼ˆç”¨äºæ¥æ”¶åª’ä½“æµï¼‰
                pc.addTransceiver('video', { direction: 'recvonly' });
                pc.addTransceiver('audio', { direction: 'recvonly' });
                
                // ICE å€™é€‰ç»Ÿè®¡
                let candidateStats = {
                    host: 0,
                    srflx: 0,
                    relay: 0,
                    total: 0
                };
                
                // ICE å€™é€‰äº‹ä»¶
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const c = event.candidate;
                        candidateStats.total++;
                        candidateStats[c.type] = (candidateStats[c.type] || 0) + 1;
                        
                        log(`ğŸ¯ ICE å€™é€‰ #${candidateStats.total}: ${c.type} | ${c.protocol} | ${c.address}:${c.port}`, 
                            c.type === 'relay' ? 'success' : 'warn');
                        
                        if (c.type !== 'relay' && config.icePolicy === 'relay') {
                            log('âš ï¸  è­¦å‘Š: å‡ºç°äº†é relay å€™é€‰ï¼Œæ£€æŸ¥é…ç½®ï¼', 'error');
                        }
                        
                        // è¯¦ç»†å€™é€‰ä¿¡æ¯
                        log(`   candidate: ${c.candidate}`, 'info');
                    } else {
                        log('âœ… ICE å€™é€‰æ”¶é›†å®Œæˆ', 'success');
                        log(`   ğŸ“Š ç»Ÿè®¡: host=${candidateStats.host}, srflx=${candidateStats.srflx}, relay=${candidateStats.relay}`, 'info');
                        
                        // è¯Šæ–­ï¼šå¦‚æœå¼ºåˆ¶ relay ä½†æ²¡æœ‰ relay å€™é€‰
                        if (config.icePolicy === 'relay' && candidateStats.relay === 0) {
                            log('', 'error');
                            log('âŒâŒâŒ ä¸¥é‡é—®é¢˜ï¼šå¼ºåˆ¶ TURN ä¸­ç»§ï¼Œä½†æ²¡æœ‰æ”¶é›†åˆ°ä»»ä½• relay å€™é€‰ï¼', 'error');
                            log('', 'error');
                            log('ğŸ” å¯èƒ½çš„åŸå› ï¼š', 'error');
                            log('   1ï¸âƒ£  TURN æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼ˆæ£€æŸ¥åŸŸåè§£æå’Œç«¯å£è¿é€šæ€§ï¼‰', 'error');
                            log(`   2ï¸âƒ£  TURN è®¤è¯å¤±è´¥ï¼ˆå½“å‰ï¼š${config.turnUsername}ï¼‰`, 'error');
                            log('   3ï¸âƒ£  ZLM config.ini ä¸­ externIP æœªé…ç½®æˆ–é…ç½®é”™è¯¯', 'error');
                            log('   4ï¸âƒ£  ZLM config.ini ä¸­ enableTurn=0 æˆ–æœªå¯ç”¨', 'error');
                            log('   5ï¸âƒ£  é˜²ç«å¢™é˜»æ­¢äº† 3478/udp ç«¯å£', 'error');
                            log('', 'error');
                            log('ğŸ’¡ å»ºè®®æ“ä½œï¼š', 'warn');
                            log('   â€¢ åœ¨æµè§ˆå™¨æ§åˆ¶å°æŸ¥çœ‹æ˜¯å¦æœ‰ TURN ç›¸å…³é”™è¯¯', 'warn');
                            log('   â€¢ æ‰“å¼€æµè§ˆå™¨ chrome://webrtc-internals æŸ¥çœ‹è¯¦ç»†æ—¥å¿—', 'warn');
                            log('   â€¢ å‚è€ƒ "è¯Šæ–­è„šæœ¬-ZLMé…ç½®æ£€æŸ¥.md" æ–‡ä»¶', 'warn');
                            log('', 'warn');
                        } else if (config.icePolicy === 'relay' && candidateStats.relay > 0) {
                            log(`âœ… æˆåŠŸè·å– ${candidateStats.relay} ä¸ª relay å€™é€‰`, 'success');
                        }
                    }
                };
                
                // ICE æ”¶é›†çŠ¶æ€
                pc.onicegatheringstatechange = () => {
                    log(`ğŸ“Š ICE æ”¶é›†çŠ¶æ€: ${pc.iceGatheringState}`, 'info');
                };
                
                // ICE è¿æ¥çŠ¶æ€
                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    log(`ğŸ”— ICE è¿æ¥çŠ¶æ€: ${state}`, state === 'connected' ? 'success' : 'info');
                    updateStatus(pc.connectionState, state);
                    
                    if (state === 'connected') {
                        const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                        log(`ğŸ‰ è¿æ¥å»ºç«‹æˆåŠŸï¼è€—æ—¶: ${elapsed} ç§’`, 'success');
                        
                        // è‡ªåŠ¨æ£€æŸ¥è¿æ¥ç±»å‹
                        setTimeout(() => checkConnectionType(), 1000);
                    } else if (state === 'failed') {
                        log('âŒ ICE è¿æ¥å¤±è´¥ï¼', 'error');
                    }
                };
                
                // è¿æ¥çŠ¶æ€
                pc.onconnectionstatechange = () => {
                    log(`ğŸ“¡ è¿æ¥çŠ¶æ€: ${pc.connectionState}`, 'info');
                    updateStatus(pc.connectionState, pc.iceConnectionState);
                };
                
                // æ¥æ”¶åª’ä½“æµ
                pc.ontrack = (event) => {
                    log('ğŸ“º æ”¶åˆ°åª’ä½“è½¨é“: ' + event.track.kind, 'success');
                    const video = document.getElementById('video');
                    if (!video.srcObject) {
                        video.srcObject = event.streams[0];
                        log('âœ… è§†é¢‘æµå·²è®¾ç½®', 'success');
                    }
                };
                
                // åˆ›å»º Offer
                log('', 'info');
                log('ğŸ“ åˆ›å»º SDP Offer...', 'info');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                log('âœ… æœ¬åœ° SDP å·²è®¾ç½®', 'success');
                
                // ğŸ”§ ä¸´æ—¶ï¼šä¸ä¿®æ”¹ SDPï¼Œç›´æ¥ä½¿ç”¨åŸå§‹çš„
                let sdp = offer.sdp;
                
                log(`ğŸ“ ä½¿ç”¨åŸå§‹ SDPï¼ˆæœªä¿®æ”¹ï¼‰`, 'info');
                
                // æ˜¾ç¤ºåŸå§‹ origin
                const originRegex = /^o=(.+)$/m;
                const originMatch = sdp.match(originRegex);
                if (originMatch) {
                    log(`   åŸå§‹ origin: o=${originMatch[1]}`, 'info');
                }
                
                // å‘é€åˆ° ZLM
                log('', 'info');
                log('ğŸ“¤ å‘é€ Offer åˆ° ZLM...', 'info');
                
                const url = `${config.serverUrl}?app=${config.app}&stream=${config.stream}&type=play`;
                log(`   URL: ${url}`, 'info');
                
                // æ˜¾ç¤ºå®Œæ•´çš„ SDPï¼ˆç”¨äºè°ƒè¯•ï¼‰
                log('', 'info');
                log('ğŸ“‹ å®Œæ•´çš„ SDP Offer:', 'info');
                sdp.split('\n').forEach((line, idx) => {
                    if (line.trim()) {
                        log(`   ${idx + 1}: ${line}`, 'info');
                    }
                });
                log('', 'info');
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8'  // â† ä¿®å¤ï¼šæ”¹ä¸ºtext/plain
                    },
                    body: sdp  // â† ä¿®å¤ï¼šç›´æ¥å‘é€SDPæ–‡æœ¬ï¼Œä¸æ˜¯JSON
                });
                
                const result = await response.json();
                log(`ğŸ“¥ æ”¶åˆ°å“åº”: code=${result.code}`, result.code === 0 ? 'success' : 'error');
                
                if (result.code === 0) {
                    // è®¾ç½®è¿œç«¯ SDP
                    await pc.setRemoteDescription({
                        type: 'answer',
                        sdp: result.sdp
                    });
                    log('âœ… è¿œç«¯ SDP å·²è®¾ç½®', 'success');
                    log('', 'info');
                    log('â³ ç­‰å¾… ICE è¿æ¥å»ºç«‹...', 'info');
                } else {
                    log(`âŒ ZLM è¿”å›é”™è¯¯: ${JSON.stringify(result)}`, 'error');
                }
                
            } catch (error) {
                log(`âŒ é”™è¯¯: ${error.message}`, 'error');
                console.error(error);
            }
        }
        
        // æ£€æŸ¥è¿æ¥ç±»å‹
        async function checkConnectionType() {
            if (!pc) {
                log('âŒ è¯·å…ˆå¼€å§‹æµ‹è¯•', 'error');
                return;
            }
            
            log('', 'info');
            log('========================================', 'info');
            log('ğŸ” æ£€æŸ¥è¿æ¥ç±»å‹...', 'info');
            log('========================================', 'info');
            
            const stats = await pc.getStats();
            let foundRelay = false;
            let candidateInfo = {};
            
            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    log(`âœ… æˆåŠŸçš„å€™é€‰å¯¹: ${report.id}`, 'success');
                    log(`   çŠ¶æ€: ${report.state}`, 'info');
                    log(`   ä¼˜å…ˆçº§: ${report.priority}`, 'info');
                    
                    // æŸ¥æ‰¾å€™é€‰è¯¦æƒ…
                    stats.forEach(r => {
                        if (r.id === report.localCandidateId) {
                            candidateInfo.local = r;
                            const type = r.candidateType || r.type;
                            log(`   æœ¬åœ°å€™é€‰: ${type}`, type === 'relay' ? 'success' : 'warn');
                            log(`     åœ°å€: ${r.address || r.ip}:${r.port}`, 'info');
                            log(`     åè®®: ${r.protocol}`, 'info');
                            if (r.relayProtocol) {
                                log(`     ä¸­ç»§åè®®: ${r.relayProtocol}`, 'info');
                                log(`     âœ… æ£€æµ‹åˆ°æœ¬åœ° relayProtocolï¼Œç¡®è®¤ä½¿ç”¨ TURNï¼`, 'success');
                            }
                            // ğŸ”¥ å¢å¼ºæ£€æµ‹ï¼šrelay å€™é€‰æˆ–æœ‰ relayProtocol çš„å€™é€‰éƒ½ç®— TURN
                            if (type === 'relay' || r.relayProtocol) foundRelay = true;
                        }
                        if (r.id === report.remoteCandidateId) {
                            candidateInfo.remote = r;
                            const type = r.candidateType || r.type;
                            log(`   è¿œç«¯å€™é€‰: ${type}`, 'info');
                            log(`     åœ°å€: ${r.address || r.ip}:${r.port}`, 'info');
                            log(`     åè®®: ${r.protocol}`, 'info');
                            // ğŸ”¥ å¢å¼ºæ£€æµ‹ï¼šæ£€æŸ¥è¿œç«¯å€™é€‰çš„ relayProtocol
                            if (r.relayProtocol) {
                                log(`     ä¸­ç»§åè®®: ${r.relayProtocol}`, 'info');
                                log(`     âœ… æ£€æµ‹åˆ°è¿œç«¯ relayProtocolï¼Œç¡®è®¤ä½¿ç”¨ TURNï¼`, 'success');
                                foundRelay = true;
                            }
                            // ğŸ”¥ å¢å¼ºæ£€æµ‹ï¼šè¿œç«¯æ˜¯ relay ç±»å‹ä¹Ÿç®— TURN
                            if (type === 'relay') {
                                foundRelay = true;
                            }
                        }
                    });
                    
                    // ğŸ”¥ æ–°å¢ï¼šæ£€æŸ¥å€™é€‰å¯¹çš„è¯¦ç»†ä¿¡æ¯
                    log('   ---', 'info');
                    log(`   ğŸ“Š å€™é€‰å¯¹è¯¦ç»†ä¿¡æ¯:`, 'info');
                    log(`     æœ¬åœ°ç±»å‹: ${candidateInfo.local?.candidateType || candidateInfo.local?.type}`, 'info');
                    log(`     è¿œç«¯ç±»å‹: ${candidateInfo.remote?.candidateType || candidateInfo.remote?.type}`, 'info');
                    log(`     æœ¬åœ° relayProtocol: ${candidateInfo.local?.relayProtocol || 'æ— '}`, 'info');
                    log(`     è¿œç«¯ relayProtocol: ${candidateInfo.remote?.relayProtocol || 'æ— '}`, 'info');
                    
                    // ğŸ”¥ æœ€ç»ˆåˆ¤æ–­ï¼šåªè¦æœ¬åœ°æˆ–è¿œç«¯æœ‰ relayProtocolï¼Œå°±æ˜¯ TURN
                    if (candidateInfo.local?.relayProtocol || candidateInfo.remote?.relayProtocol) {
                        log(`     ğŸ¯ åˆ¤å®šï¼šé€šè¿‡ relayProtocol ç¡®è®¤ä½¿ç”¨ TURNï¼`, 'success');
                        foundRelay = true;
                    }
                }
            });
            
            log('', 'info');
            if (foundRelay) {
                log('ğŸ‰ğŸ‰ğŸ‰ ç¡®è®¤ï¼šæ­£åœ¨ä½¿ç”¨ TURN ä¸­ç»§ï¼', 'success');
                log('âœ… åª’ä½“æ•°æ®é€šè¿‡æœåŠ¡å™¨è½¬å‘', 'success');
                document.getElementById('candidateType').textContent = 'TURN Relay';
                document.getElementById('candidateType').style.color = '#28a745';
            } else {
                log('âš ï¸âš ï¸âš ï¸ è­¦å‘Šï¼šæ²¡æœ‰ä½¿ç”¨ TURN ä¸­ç»§ï¼', 'error');
                log('âŒ å½“å‰ä½¿ç”¨ P2P ç›´è¿', 'error');
                const localType = candidateInfo.local?.candidateType || candidateInfo.local?.type || 'æœªçŸ¥';
                document.getElementById('candidateType').textContent = localType;
                document.getElementById('candidateType').style.color = '#dc3545';
            }
        }
        
        // è·å–è¯¦ç»†ç»Ÿè®¡
        async function getDetailedStats() {
            if (!pc) {
                log('âŒ è¯·å…ˆå¼€å§‹æµ‹è¯•', 'error');
                return;
            }
            
            log('', 'info');
            log('========================================', 'info');
            log('ğŸ“Š è¯¦ç»†ç»Ÿè®¡ä¿¡æ¯', 'info');
            log('========================================', 'info');
            
            const stats = await pc.getStats();
            
            stats.forEach(report => {
                if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                    log('ğŸ“ˆ æ´»è·ƒè¿æ¥ç»Ÿè®¡:', 'success');
                    log(`   å¾€è¿”å»¶è¿Ÿ (RTT): ${report.currentRoundTripTime ? (report.currentRoundTripTime * 1000).toFixed(2) + ' ms' : 'æœªçŸ¥'}`, 'info');
                    log(`   å¯ç”¨å¸¦å®½: ${report.availableOutgoingBitrate ? (report.availableOutgoingBitrate / 1000000).toFixed(2) + ' Mbps' : 'æœªçŸ¥'}`, 'info');
                    log(`   å‘é€å­—èŠ‚: ${report.bytesSent || 0}`, 'info');
                    log(`   æ¥æ”¶å­—èŠ‚: ${report.bytesReceived || 0}`, 'info');
                    log(`   å‘é€æ•°æ®åŒ…: ${report.packetsSent || 0}`, 'info');
                    log(`   æ¥æ”¶æ•°æ®åŒ…: ${report.packetsReceived || 0}`, 'info');
                    
                    // æ›´æ–° RTT æ˜¾ç¤º
                    if (report.currentRoundTripTime) {
                        const rtt = (report.currentRoundTripTime * 1000).toFixed(0);
                        document.getElementById('rtt').textContent = rtt + ' ms';
                    }
                }
                
                if (report.type === 'inbound-rtp' && report.kind === 'video') {
                    log('ğŸ“¹ è§†é¢‘æ¥æ”¶ç»Ÿè®¡:', 'info');
                    log(`   æ¥æ”¶å­—èŠ‚: ${report.bytesReceived || 0}`, 'info');
                    log(`   æ¥æ”¶æ•°æ®åŒ…: ${report.packetsReceived || 0}`, 'info');
                    log(`   ä¸¢åŒ…: ${report.packetsLost || 0}`, 'info');
                    log(`   æŠ–åŠ¨: ${report.jitter ? (report.jitter * 1000).toFixed(2) + ' ms' : 'æœªçŸ¥'}`, 'info');
                }
                
                if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                    log('ğŸ”Š éŸ³é¢‘æ¥æ”¶ç»Ÿè®¡:', 'info');
                    log(`   æ¥æ”¶å­—èŠ‚: ${report.bytesReceived || 0}`, 'info');
                    log(`   æ¥æ”¶æ•°æ®åŒ…: ${report.packetsReceived || 0}`, 'info');
                    log(`   ä¸¢åŒ…: ${report.packetsLost || 0}`, 'info');
                }
            });
        }
        
        // åœæ­¢æµ‹è¯•
        function stopTest() {
            if (pc) {
                pc.close();
                pc = null;
                log('â¹ï¸  æµ‹è¯•å·²åœæ­¢', 'warn');
                updateStatus('disconnected', 'closed');
                document.getElementById('candidateType').textContent = '-';
                document.getElementById('rtt').textContent = '- ms';
                
                const video = document.getElementById('video');
                video.srcObject = null;
            } else {
                log('âš ï¸  æ²¡æœ‰æ´»è·ƒçš„è¿æ¥', 'warn');
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆ
        window.onload = () => {
            log('âœ… TURN æµ‹è¯•å·¥å…·å·²å°±ç»ª', 'success');
            log('ğŸ’¡ è¯·é…ç½®è¿œç¨‹æœåŠ¡å™¨å‚æ•°åç‚¹å‡»"å¼€å§‹æµ‹è¯•"', 'info');
            log('', 'info');
            log('ğŸ“ é…ç½®ç¤ºä¾‹:', 'warn');
            log('   ZLM æœåŠ¡å™¨: https://streams.vhalo.net:1443/index/api/webrtc', 'info');
            log('   TURN æœåŠ¡å™¨: turn:streams.vhalo.net:3478?transport=udp', 'info');
            log('   åº”ç”¨å: live', 'info');
            log('   æµID: test', 'info');
            log('', 'info');
            
            // å°è¯•ä»å½“å‰ URL è·å–åŸŸåï¼ˆå¦‚æœé¡µé¢éƒ¨ç½²åœ¨æœåŠ¡å™¨ä¸Šï¼‰
            // âš ï¸ å·²ç¦ç”¨è‡ªåŠ¨æ£€æµ‹ï¼Œä½¿ç”¨HTMLä¸­å†™æ­»çš„é»˜è®¤é…ç½®
            /*
            const hostname = window.location.hostname;
            if (hostname && hostname !== 'localhost' && hostname !== '') {
                const protocol = window.location.protocol;
                const port = window.location.port || (protocol === 'https:' ? '443' : '80');
                
                // è®¾ç½®é»˜è®¤å€¼
                const serverUrl = `${protocol}//${hostname}${port !== '80' && port !== '443' ? ':' + port : ''}/index/api/webrtc`;
                const turnUrl = `turn:${hostname}:3478?transport=udp`;
                
                document.getElementById('serverUrl').value = serverUrl;
                document.getElementById('turnServer').value = turnUrl;
                
                log(`ğŸ’¡ è‡ªåŠ¨æ£€æµ‹åˆ°æœåŠ¡å™¨é…ç½®:`, 'success');
                log(`   åŸŸå: ${hostname}`, 'info');
                log(`   ZLM åœ°å€: ${serverUrl}`, 'info');
                log(`   TURN åœ°å€: ${turnUrl}`, 'info');
                log('', 'info');
            } else {
                log('âš ï¸  é¡µé¢åœ¨æœ¬åœ°æ‰“å¼€ï¼Œè¯·æ‰‹åŠ¨é…ç½®æœåŠ¡å™¨åœ°å€', 'warn');
                log('', 'info');
            }
            */
            log('ğŸ’¡ ä½¿ç”¨é¢„è®¾é…ç½®ï¼Œå¦‚éœ€ä¿®æ”¹è¯·ç›´æ¥ç¼–è¾‘è¾“å…¥æ¡†', 'info');
            log('', 'info');
        };
        
        // å®šæœŸæ›´æ–°ç»Ÿè®¡ï¼ˆæ¯ 5 ç§’ï¼‰
        setInterval(async () => {
            if (pc && pc.iceConnectionState === 'connected') {
                const stats = await pc.getStats();
                stats.forEach(report => {
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        if (report.currentRoundTripTime) {
                            const rtt = (report.currentRoundTripTime * 1000).toFixed(0);
                            document.getElementById('rtt').textContent = rtt + ' ms';
                        }
                    }
                });
            }
        }, 5000);
    </script>
</body>
</html>

