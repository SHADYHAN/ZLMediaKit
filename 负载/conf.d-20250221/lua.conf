preread_by_lua_block {
    local backend_ips = ngx.shared.backend_ips
    local backend_list = ngx.shared.backend_list
    local high_traffic = ngx.shared.high_traffic_backends

    -- 获取当前后端列表
    local backends_str = backend_list:get("backends") or "10.1.100.11,10.1.100.13"
    local backends = {}
    for ip in string.gmatch(backends_str, "[^,]+") do
        table.insert(backends, ip)
    end

    -- 获取高流量后端列表
    local high_traffic_ips = {}
    local keys = high_traffic:get_keys(0)  -- 获取所有高流量IP
    for _, ip in ipairs(keys) do
        high_traffic_ips[ip] = true
    end

    local client_ip = ngx.var.remote_addr
    local backend_ip = backend_ips:get(client_ip)

    if not backend_ip or not table.contains(backends, backend_ip) then
        -- 生成可用后端列表（排除高流量节点）
        local available_backends = {}
        for _, ip in ipairs(backends) do
            if not high_traffic_ips[ip] then
                table.insert(available_backends, ip)
            end
        end

        -- 优先选择非高流量节点
        if #available_backends > 0 then
            backend_ip = available_backends[math.random(#available_backends)]
        else
            -- 全部节点高流量时回退到原始列表
            backend_ip = backends[math.random(#backends)]
            ngx.log(ngx.WARN, "All backends in high traffic, fallback to random selection")
        end

        backend_ips:set(client_ip, backend_ip)
        ngx.log(ngx.ERR, "Stored backend_ip: ", backend_ip, " for client_ip: ", client_ip)
    else
        -- 即使当前后端处于高流量状态也继续使用
        ngx.log(ngx.ERR, "Retrieved backend_ip: ", backend_ip, " for client_ip: ", client_ip)
    end

    ngx.var.backend_ip = backend_ip
}
